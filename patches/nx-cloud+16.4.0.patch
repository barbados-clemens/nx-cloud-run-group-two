diff --git a/node_modules/nx-cloud/lib/core/api/run-group.api.js b/node_modules/nx-cloud/lib/core/api/run-group.api.js
index e480c12..5c35710 100644
--- a/node_modules/nx-cloud/lib/core/api/run-group.api.js
+++ b/node_modules/nx-cloud/lib/core/api/run-group.api.js
@@ -1 +1,147 @@
-const a1_0x54d9=['axiosMultipleTries','error','defineProperty','../../utilities/axios','apiAxiosInstance','exit','value','/nx-cloud/executions/create-run-group','then','createMetricRecorder','post','createApiAxiosInstance','recordMetric','axiosException','../../utilities/nx-imports-light','response','__awaiter','createRunGroup','throw','message','RUNNER_FAILURE_PERF_ENTRY','next','__esModule','mapRespToPerfEntry'];(function(_0x4f2746,_0x54d920){const _0x4a6e45=function(_0x4642de){while(--_0x4642de){_0x4f2746['push'](_0x4f2746['shift']());}};_0x4a6e45(++_0x54d920);}(a1_0x54d9,0x1b0));const a1_0x4a6e=function(_0x4f2746,_0x54d920){_0x4f2746=_0x4f2746-0x0;let _0x4a6e45=a1_0x54d9[_0x4f2746];return _0x4a6e45;};'use strict';var __awaiter=this&&this[a1_0x4a6e('0x10')]||function(_0x5071ca,_0xd3a950,_0x270073,_0x4fdfb7){function _0x2498cb(_0x323067){return _0x323067 instanceof _0x270073?_0x323067:new _0x270073(function(_0x16f2c9){_0x16f2c9(_0x323067);});}return new(_0x270073||(_0x270073=Promise))(function(_0x2d34e1,_0x367325){function _0x1e196e(_0x329b6b){try{_0x230cc3(_0x4fdfb7[a1_0x4a6e('0x15')](_0x329b6b));}catch(_0x199fb1){_0x367325(_0x199fb1);}}function _0x9e8812(_0x3cfeec){try{_0x230cc3(_0x4fdfb7[a1_0x4a6e('0x12')](_0x3cfeec));}catch(_0x47b03d){_0x367325(_0x47b03d);}}function _0x230cc3(_0x56b2c8){_0x56b2c8['done']?_0x2d34e1(_0x56b2c8[a1_0x4a6e('0x6')]):_0x2498cb(_0x56b2c8[a1_0x4a6e('0x6')])[a1_0x4a6e('0x8')](_0x1e196e,_0x9e8812);}_0x230cc3((_0x4fdfb7=_0x4fdfb7['apply'](_0x5071ca,_0xd3a950||[]))[a1_0x4a6e('0x15')]());});};Object[a1_0x4a6e('0x2')](exports,a1_0x4a6e('0x16'),{'value':!![]});exports['RunGroupApi']=void 0x0;const axios_1=require(a1_0x4a6e('0x3'));const metric_logger_1=require('../../utilities/metric-logger');const {output}=require(a1_0x4a6e('0xe'));class RunGroupApi{constructor(_0x5bdb5f){this[a1_0x4a6e('0x4')]=(0x0,axios_1[a1_0x4a6e('0xb')])(_0x5bdb5f);}[a1_0x4a6e('0x11')](_0x24e54f,_0x58f64d,_0x3f4cca,_0x151121,_0x23d5e8,_0x284c6c,_0x36073c,_0x19ad94,_0x3f1568){var _0x52b573;return __awaiter(this,void 0x0,void 0x0,function*(){const _0x2a0ed2=(0x0,metric_logger_1[a1_0x4a6e('0x9')])(a1_0x4a6e('0x11'));try{const _0x1a03d3=yield(0x0,axios_1[a1_0x4a6e('0x0')])(()=>this[a1_0x4a6e('0x4')]['post'](a1_0x4a6e('0x7'),{'branch':_0x24e54f,'runGroup':_0x58f64d,'ciExecutionId':_0x3f4cca,'ciExecutionEnv':_0x151121,'stopAgentsOnFailure':_0x23d5e8,'agentCount':_0x284c6c,'stopAgentsAfter':_0x36073c,'commitSha':_0x19ad94}));_0x2a0ed2[a1_0x4a6e('0xc')]((0x0,metric_logger_1[a1_0x4a6e('0x17')])(_0x1a03d3));}catch(_0x427452){_0x2a0ed2['recordMetric'](((_0x52b573=_0x427452===null||_0x427452===void 0x0?void 0x0:_0x427452[a1_0x4a6e('0xd')])===null||_0x52b573===void 0x0?void 0x0:_0x52b573['response'])?(0x0,metric_logger_1[a1_0x4a6e('0x17')])(_0x427452[a1_0x4a6e('0xd')][a1_0x4a6e('0xf')]):metric_logger_1[a1_0x4a6e('0x14')]);output[a1_0x4a6e('0x1')]({'title':_0x427452[a1_0x4a6e('0x13')]});process[a1_0x4a6e('0x5')](0x1);}});}['completeRunGroup'](_0x14fc92,_0x306333,_0x37f19a,_0x27a5dc){var _0x953608;return __awaiter(this,void 0x0,void 0x0,function*(){const _0x2c535c=(0x0,metric_logger_1[a1_0x4a6e('0x9')])('completeRunGroup');try{const _0x244adc=yield(0x0,axios_1[a1_0x4a6e('0x0')])(()=>this[a1_0x4a6e('0x4')][a1_0x4a6e('0xa')]('/nx-cloud/executions/complete-run-group',{'branch':_0x14fc92,'runGroup':_0x306333,'ciExecutionId':_0x37f19a,'ciExecutionEnv':_0x27a5dc}));_0x2c535c[a1_0x4a6e('0xc')]((0x0,metric_logger_1[a1_0x4a6e('0x17')])(_0x244adc));}catch(_0x52bd5a){_0x2c535c['recordMetric'](((_0x953608=_0x52bd5a===null||_0x52bd5a===void 0x0?void 0x0:_0x52bd5a[a1_0x4a6e('0xd')])===null||_0x953608===void 0x0?void 0x0:_0x953608[a1_0x4a6e('0xf')])?(0x0,metric_logger_1[a1_0x4a6e('0x17')])(_0x52bd5a[a1_0x4a6e('0xd')][a1_0x4a6e('0xf')]):metric_logger_1['RUNNER_FAILURE_PERF_ENTRY']);output['error']({'title':_0x52bd5a[a1_0x4a6e('0x13')]});process[a1_0x4a6e('0x5')](0x1);}});}}exports['RunGroupApi']=RunGroupApi;
\ No newline at end of file
+'use strict';
+var __awaiter =
+  (this && this.__awaiter) ||
+  function (thisArg, _arguments, P, generator) {
+    function adopt(value) {
+      return value instanceof P
+        ? value
+        : new P(function (resolve) {
+            resolve(value);
+          });
+    }
+    return new (P || (P = Promise))(function (resolve, reject) {
+      function fulfilled(value) {
+        try {
+          step(generator.next(value));
+        } catch (e) {
+          reject(e);
+        }
+      }
+      function rejected(value) {
+        try {
+          step(generator['throw'](value));
+        } catch (e) {
+          reject(e);
+        }
+      }
+      function step(result) {
+        result.done
+          ? resolve(result.value)
+          : adopt(result.value).then(fulfilled, rejected);
+      }
+      step((generator = generator.apply(thisArg, _arguments || [])).next());
+    });
+  };
+Object.defineProperty(exports, '__esModule', { value: true });
+exports.RunGroupApi = void 0;
+const axios_1 = require('../../utilities/axios');
+const metric_logger_1 = require('../../utilities/metric-logger');
+const { output } = require('../../utilities/nx-imports-light');
+class RunGroupApi {
+  constructor(options) {
+    this.apiAxiosInstance = (0, axios_1.createApiAxiosInstance)(options);
+  }
+  createRunGroup(
+    branch,
+    runGroup,
+    ciExecutionId,
+    ciExecutionEnv,
+    stopAgentsOnFailure,
+    agentCount,
+    stopAgentsAfter,
+    commitSha,
+    commitRef
+  ) {
+    var _a;
+    return __awaiter(this, void 0, void 0, function* () {
+      const recorder = (0, metric_logger_1.createMetricRecorder)(
+        'createRunGroup'
+      );
+      try {
+        console.log('creating run group', {
+          branch,
+          runGroup,
+          ciExecutionId,
+          ciExecutionEnv,
+          stopAgentsOnFailure,
+          agentCount,
+          stopAgentsAfter,
+          commitSha,
+        });
+        const resp = yield (0, axios_1.axiosMultipleTries)(() =>
+          this.apiAxiosInstance.post('/nx-cloud/executions/create-run-group', {
+            branch,
+            runGroup,
+            ciExecutionId,
+            ciExecutionEnv,
+            stopAgentsOnFailure,
+            agentCount,
+            stopAgentsAfter,
+            commitSha,
+          })
+        );
+        recorder.recordMetric((0, metric_logger_1.mapRespToPerfEntry)(resp));
+      } catch (e) {
+        recorder.recordMetric(
+          (
+            (_a = e === null || e === void 0 ? void 0 : e.axiosException) ===
+              null || _a === void 0
+              ? void 0
+              : _a.response
+          )
+            ? (0, metric_logger_1.mapRespToPerfEntry)(e.axiosException.response)
+            : metric_logger_1.RUNNER_FAILURE_PERF_ENTRY
+        );
+        output.error({
+          title: e.message,
+        });
+        process.exit(1);
+      }
+    });
+  }
+  completeRunGroup(branch, runGroup, ciExecutionId, ciExecutionEnv) {
+    var _a;
+    return __awaiter(this, void 0, void 0, function* () {
+      const recorder = (0, metric_logger_1.createMetricRecorder)(
+        'completeRunGroup'
+      );
+      try {
+        console.log('completing run group', {
+          branch,
+          runGroup,
+          ciExecutionId,
+          ciExecutionEnv,
+        });
+        const resp = yield (0, axios_1.axiosMultipleTries)(() =>
+          this.apiAxiosInstance.post(
+            '/nx-cloud/executions/complete-run-group',
+            {
+              branch,
+              runGroup,
+              ciExecutionId,
+              ciExecutionEnv,
+            }
+          )
+        );
+        recorder.recordMetric((0, metric_logger_1.mapRespToPerfEntry)(resp));
+      } catch (e) {
+        recorder.recordMetric(
+          (
+            (_a = e === null || e === void 0 ? void 0 : e.axiosException) ===
+              null || _a === void 0
+              ? void 0
+              : _a.response
+          )
+            ? (0, metric_logger_1.mapRespToPerfEntry)(e.axiosException.response)
+            : metric_logger_1.RUNNER_FAILURE_PERF_ENTRY
+        );
+        output.error({
+          title: e.message,
+        });
+        process.exit(1);
+      }
+    });
+  }
+}
+exports.RunGroupApi = RunGroupApi;
+//# sourceMappingURL=run-group.api.js.map
diff --git a/node_modules/nx-cloud/lib/utilities/environment.js b/node_modules/nx-cloud/lib/utilities/environment.js
index 22809f9..dcc4d31 100644
--- a/node_modules/nx-cloud/lib/utilities/environment.js
+++ b/node_modules/nx-cloud/lib/utilities/environment.js
@@ -1,234 +1,290 @@
-"use strict";
-Object.defineProperty(exports, "__esModule", { value: true });
-exports.parseCommand = exports.getMachineInfo = exports.getBranch = exports.getRunGroup = exports.getCIExecutionEnv = exports.getCIExecutionId = exports.extractGitRef = exports.extractGitSha = exports.nxInvokedByRunner = exports.agentRunningInDistributedExecution = exports.NX_CLOUD_NO_TIMEOUTS = exports.VERBOSE_LOGGING = exports.ENCRYPTION_KEY = exports.ACCESS_TOKEN = exports.NX_NO_CLOUD = exports.NUMBER_OF_AXIOS_RETRIES = exports.NX_CLOUD_FORCE_METRICS = exports.NX_CLOUD_DISTRIBUTED_EXECUTION_STOP_AGENTS_ON_FAILURE = exports.NX_CLOUD_DISTRIBUTED_EXECUTION_AGENT_COUNT = exports.DISTRIBUTED_TASK_EXECUTION_INTERNAL_ERROR_STATUS_CODE = exports.DEFAULT_FILE_SIZE_LIMIT = exports.NX_CLOUD_UNLIMITED_OUTPUT = exports.UNLIMITED_FILE_SIZE = exports.NO_COMPLETED_TASKS_TIMEOUT = exports.NO_MESSAGES_TIMEOUT = exports.UNLIMITED_TIMEOUT = void 0;
-const child_process_1 = require("child_process");
-const crypto_1 = require("crypto");
-const dotenv = require("dotenv");
-const fs_1 = require("fs");
-const node_machine_id_1 = require("node-machine-id");
-const path_1 = require("path");
-const is_ci_1 = require("./is-ci");
-const is_private_cloud_1 = require("./is-private-cloud");
+'use strict';
+Object.defineProperty(exports, '__esModule', { value: true });
+exports.parseCommand =
+  exports.getMachineInfo =
+  exports.getBranch =
+  exports.getRunGroup =
+  exports.getCIExecutionEnv =
+  exports.getCIExecutionId =
+  exports.extractGitRef =
+  exports.extractGitSha =
+  exports.nxInvokedByRunner =
+  exports.agentRunningInDistributedExecution =
+  exports.NX_CLOUD_NO_TIMEOUTS =
+  exports.VERBOSE_LOGGING =
+  exports.ENCRYPTION_KEY =
+  exports.ACCESS_TOKEN =
+  exports.NX_NO_CLOUD =
+  exports.NUMBER_OF_AXIOS_RETRIES =
+  exports.NX_CLOUD_FORCE_METRICS =
+  exports.NX_CLOUD_DISTRIBUTED_EXECUTION_STOP_AGENTS_ON_FAILURE =
+  exports.NX_CLOUD_DISTRIBUTED_EXECUTION_AGENT_COUNT =
+  exports.DISTRIBUTED_TASK_EXECUTION_INTERNAL_ERROR_STATUS_CODE =
+  exports.DEFAULT_FILE_SIZE_LIMIT =
+  exports.NX_CLOUD_UNLIMITED_OUTPUT =
+  exports.UNLIMITED_FILE_SIZE =
+  exports.NO_COMPLETED_TASKS_TIMEOUT =
+  exports.NO_MESSAGES_TIMEOUT =
+  exports.UNLIMITED_TIMEOUT =
+    void 0;
+const child_process_1 = require('child_process');
+const crypto_1 = require('crypto');
+const dotenv = require('dotenv');
+const fs_1 = require('fs');
+const node_machine_id_1 = require('node-machine-id');
+const path_1 = require('path');
+const is_ci_1 = require('./is-ci');
+const is_private_cloud_1 = require('./is-private-cloud');
 const { workspaceRoot } = require('./nx-imports-light');
 // Set once
 exports.UNLIMITED_TIMEOUT = 9999999;
 exports.NO_MESSAGES_TIMEOUT = process.env.NX_CLOUD_AGENT_TIMEOUT_MS
-    ? Number(process.env.NX_CLOUD_AGENT_TIMEOUT_MS)
-    : 3600000; // 60 minutes
+  ? Number(process.env.NX_CLOUD_AGENT_TIMEOUT_MS)
+  : 3600000; // 60 minutes
 exports.NO_COMPLETED_TASKS_TIMEOUT = process.env
-    .NX_CLOUD_ORCHESTRATOR_TIMEOUT_MS
-    ? Number(process.env.NX_CLOUD_ORCHESTRATOR_TIMEOUT_MS)
-    : 3600000; // 60 minutes
+  .NX_CLOUD_ORCHESTRATOR_TIMEOUT_MS
+  ? Number(process.env.NX_CLOUD_ORCHESTRATOR_TIMEOUT_MS)
+  : 3600000; // 60 minutes
 exports.UNLIMITED_FILE_SIZE = 1000 * 1000 * 10000;
-exports.NX_CLOUD_UNLIMITED_OUTPUT = process.env.NX_CLOUD_UNLIMITED_OUTPUT === 'true';
+exports.NX_CLOUD_UNLIMITED_OUTPUT =
+  process.env.NX_CLOUD_UNLIMITED_OUTPUT === 'true';
 exports.DEFAULT_FILE_SIZE_LIMIT = 1000 * 1000 * 300;
 exports.DISTRIBUTED_TASK_EXECUTION_INTERNAL_ERROR_STATUS_CODE = 166;
 exports.NX_CLOUD_DISTRIBUTED_EXECUTION_AGENT_COUNT = process.env
-    .NX_CLOUD_DISTRIBUTED_EXECUTION_AGENT_COUNT
-    ? Number(process.env.NX_CLOUD_DISTRIBUTED_EXECUTION_AGENT_COUNT)
-    : null;
-exports.NX_CLOUD_DISTRIBUTED_EXECUTION_STOP_AGENTS_ON_FAILURE = process.env.NX_CLOUD_DISTRIBUTED_EXECUTION_STOP_AGENTS_ON_FAILURE != 'false';
+  .NX_CLOUD_DISTRIBUTED_EXECUTION_AGENT_COUNT
+  ? Number(process.env.NX_CLOUD_DISTRIBUTED_EXECUTION_AGENT_COUNT)
+  : null;
+exports.NX_CLOUD_DISTRIBUTED_EXECUTION_STOP_AGENTS_ON_FAILURE =
+  process.env.NX_CLOUD_DISTRIBUTED_EXECUTION_STOP_AGENTS_ON_FAILURE != 'false';
 exports.NX_CLOUD_FORCE_METRICS = process.env.NX_CLOUD_FORCE_METRICS === 'true';
 exports.NUMBER_OF_AXIOS_RETRIES = process.env.NX_CLOUD_NUMBER_OF_RETRIES
-    ? Number(process.env.NX_CLOUD_NUMBER_OF_RETRIES)
-    : (0, is_ci_1.isCI)()
-        ? 10
-        : 1;
+  ? Number(process.env.NX_CLOUD_NUMBER_OF_RETRIES)
+  : (0, is_ci_1.isCI)()
+  ? 10
+  : 1;
 exports.NX_NO_CLOUD = process.env.NX_NO_CLOUD === 'true';
 loadEnvVars();
 function agentRunningInDistributedExecution(distributedExecutionId) {
-    return !!distributedExecutionId;
+  return !!distributedExecutionId;
 }
 exports.agentRunningInDistributedExecution = agentRunningInDistributedExecution;
 function nxInvokedByRunner() {
-    return (process.env.NX_INVOKED_BY_RUNNER === 'true' ||
-        process.env.NX_CLOUD === 'false');
+  return (
+    process.env.NX_INVOKED_BY_RUNNER === 'true' ||
+    process.env.NX_CLOUD === 'false'
+  );
 }
 exports.nxInvokedByRunner = nxInvokedByRunner;
 function extractGitSha() {
-    try {
-        return (0, child_process_1.execSync)(`git rev-parse HEAD`, { stdio: 'pipe' }).toString().trim();
-    }
-    catch (e) {
-        return undefined;
-    }
+  console.log('extracting git sha');
+  try {
+    console.log(
+      (0, child_process_1.execSync)(`git rev-parse HEAD`, { stdio: 'pipe' })
+        .toString()
+        .trim()
+    );
+    return (0, child_process_1.execSync)(`git rev-parse HEAD`, {
+      stdio: 'pipe',
+    })
+      .toString()
+      .trim();
+  } catch (e) {
+    console.log('failed to extract git sha', e);
+    return undefined;
+  }
 }
 exports.extractGitSha = extractGitSha;
 function extractGitRef() {
-    try {
-        return (0, child_process_1.execSync)(`git rev-parse --symbolic-full-name HEAD`, {
-            stdio: 'pipe',
-        })
-            .toString()
-            .trim();
-    }
-    catch (e) {
-        return undefined;
-    }
+  try {
+    return (0, child_process_1.execSync)(
+      `git rev-parse --symbolic-full-name HEAD`,
+      {
+        stdio: 'pipe',
+      }
+    )
+      .toString()
+      .trim();
+  } catch (e) {
+    return undefined;
+  }
 }
 exports.extractGitRef = extractGitRef;
 function parseEnv() {
-    try {
-        const envContents = (0, fs_1.readFileSync)((0, path_1.join)(workspaceRoot, 'nx-cloud.env'));
-        return dotenv.parse(envContents);
-    }
-    catch (e) {
-        return {};
-    }
+  try {
+    const envContents = (0, fs_1.readFileSync)(
+      (0, path_1.join)(workspaceRoot, 'nx-cloud.env')
+    );
+    return dotenv.parse(envContents);
+  } catch (e) {
+    return {};
+  }
 }
 function loadEnvVars() {
-    const parsed = parseEnv();
-    exports.ACCESS_TOKEN =
-        process.env.NX_CLOUD_AUTH_TOKEN ||
-            process.env.NX_CLOUD_ACCESS_TOKEN ||
-            parsed.NX_CLOUD_AUTH_TOKEN ||
-            parsed.NX_CLOUD_ACCESS_TOKEN;
-    exports.ENCRYPTION_KEY =
-        process.env.NX_CLOUD_ENCRYPTION_KEY || parsed.NX_CLOUD_ENCRYPTION_KEY;
-    exports.VERBOSE_LOGGING =
-        process.env.NX_VERBOSE_LOGGING === 'true' ||
-            parsed.NX_VERBOSE_LOGGING === 'true';
-    exports.NX_CLOUD_NO_TIMEOUTS =
-        process.env.NX_CLOUD_NO_TIMEOUTS === 'true' ||
-            parsed.NX_CLOUD_NO_TIMEOUTS === 'true';
+  const parsed = parseEnv();
+  exports.ACCESS_TOKEN =
+    process.env.NX_CLOUD_AUTH_TOKEN ||
+    process.env.NX_CLOUD_ACCESS_TOKEN ||
+    parsed.NX_CLOUD_AUTH_TOKEN ||
+    parsed.NX_CLOUD_ACCESS_TOKEN;
+  exports.ENCRYPTION_KEY =
+    process.env.NX_CLOUD_ENCRYPTION_KEY || parsed.NX_CLOUD_ENCRYPTION_KEY;
+  exports.VERBOSE_LOGGING =
+    process.env.NX_VERBOSE_LOGGING === 'true' ||
+    parsed.NX_VERBOSE_LOGGING === 'true';
+  exports.NX_CLOUD_NO_TIMEOUTS =
+    process.env.NX_CLOUD_NO_TIMEOUTS === 'true' ||
+    parsed.NX_CLOUD_NO_TIMEOUTS === 'true';
 }
 function getCIExecutionId() {
-    if ((0, is_private_cloud_1.isConnectedToPrivateCloud)())
-        return undefined;
-    return _ciExecutionId();
+  console.log('loading ciExecutionId');
+  if ((0, is_private_cloud_1.isConnectedToPrivateCloud)()) return undefined;
+  const c = _ciExecutionId();
+  console.log('loaded ciExecutionId', c);
+  return c;
 }
 exports.getCIExecutionId = getCIExecutionId;
 function _ciExecutionId() {
-    if (process.env.NX_CI_EXECUTION_ID !== undefined) {
-        return process.env.NX_CI_EXECUTION_ID;
-    }
-    // for backwards compat
-    if (process.env.NX_RUN_GROUP !== undefined) {
-        return process.env.NX_RUN_GROUP;
-    }
-    if (process.env.CIRCLECI !== undefined && process.env.CIRCLE_WORKFLOW_ID) {
-        return process.env.CIRCLE_WORKFLOW_ID;
-    }
-    if (process.env.TRAVIS_BUILD_ID !== undefined) {
-        return process.env.TRAVIS_BUILD_ID;
-    }
-    if (process.env.GITHUB_ACTIONS && process.env.GITHUB_RUN_ID) {
-        return `${process.env.GITHUB_RUN_ID}-${process.env.GITHUB_RUN_ATTEMPT}`;
-    }
-    if (process.env.BUILD_BUILDID) {
-        return process.env.BUILD_BUILDID;
-    }
-    if (process.env.BITBUCKET_BUILD_NUMBER !== undefined) {
-        return process.env.BITBUCKET_BUILD_NUMBER;
-    }
-    if (process.env.VERCEL_GIT_COMMIT_SHA !== undefined) {
-        return process.env.VERCEL_GIT_COMMIT_SHA;
-    }
-    if (process.env.CI_PIPELINE_ID) {
-        return process.env.CI_PIPELINE_ID;
-    }
-    // Jenkins
-    if (process.env.BUILD_TAG) {
-        return process.env.BUILD_TAG;
-    }
-    return null;
+  if (process.env.NX_CI_EXECUTION_ID !== undefined) {
+    return process.env.NX_CI_EXECUTION_ID;
+  }
+  // for backwards compat
+  if (process.env.NX_RUN_GROUP !== undefined) {
+    return process.env.NX_RUN_GROUP;
+  }
+  if (process.env.CIRCLECI !== undefined && process.env.CIRCLE_WORKFLOW_ID) {
+    return process.env.CIRCLE_WORKFLOW_ID;
+  }
+  if (process.env.TRAVIS_BUILD_ID !== undefined) {
+    return process.env.TRAVIS_BUILD_ID;
+  }
+  if (process.env.GITHUB_ACTIONS && process.env.GITHUB_RUN_ID) {
+    return `${process.env.GITHUB_RUN_ID}-${process.env.GITHUB_RUN_ATTEMPT}`;
+  }
+  if (process.env.BUILD_BUILDID) {
+    return process.env.BUILD_BUILDID;
+  }
+  if (process.env.BITBUCKET_BUILD_NUMBER !== undefined) {
+    return process.env.BITBUCKET_BUILD_NUMBER;
+  }
+  if (process.env.VERCEL_GIT_COMMIT_SHA !== undefined) {
+    return process.env.VERCEL_GIT_COMMIT_SHA;
+  }
+  if (process.env.CI_PIPELINE_ID) {
+    return process.env.CI_PIPELINE_ID;
+  }
+  // Jenkins
+  if (process.env.BUILD_TAG) {
+    return process.env.BUILD_TAG;
+  }
+  return null;
 }
 function getCIExecutionEnv() {
-    var _a;
-    if ((0, is_private_cloud_1.isConnectedToPrivateCloud)())
-        return undefined;
-    return (_a = process.env.NX_CI_EXECUTION_ENV) !== null && _a !== void 0 ? _a : '';
+  var _a, _b;
+  if ((0, is_private_cloud_1.isConnectedToPrivateCloud)()) return undefined;
+  console.log(
+    'loading ciExecutionEnv',
+    (_a = process.env.NX_CI_EXECUTION_ENV) !== null && _a !== void 0 ? _a : ''
+  );
+  return (_b = process.env.NX_CI_EXECUTION_ENV) !== null && _b !== void 0
+    ? _b
+    : '';
 }
 exports.getCIExecutionEnv = getCIExecutionEnv;
 function getRunGroup() {
-    if (process.env.NX_RUN_GROUP !== undefined) {
-        return process.env.NX_RUN_GROUP;
-    }
-    const ciExecutionId = _ciExecutionId();
-    if (ciExecutionId) {
-        if (getCIExecutionEnv()) {
-            return `${ciExecutionId}-${getCIExecutionEnv()}`;
-        }
-        else {
-            return ciExecutionId;
-        }
+  var _a;
+  console.log(
+    'loading runGroup',
+    (_a = process.env.NX_RUN_GROUP) !== null && _a !== void 0 ? _a : ''
+  );
+  if (process.env.NX_RUN_GROUP !== undefined) {
+    return process.env.NX_RUN_GROUP;
+  }
+  const ciExecutionId = _ciExecutionId();
+  if (ciExecutionId) {
+    if (getCIExecutionEnv()) {
+      console.log(`${ciExecutionId}-${getCIExecutionEnv()}`);
+      return `${ciExecutionId}-${getCIExecutionEnv()}`;
+    } else {
+      console.log(ciExecutionId);
+      return ciExecutionId;
     }
-    return extractGitSha();
+  }
+  return extractGitSha();
 }
 exports.getRunGroup = getRunGroup;
 function getBranch() {
-    var _a;
-    if (process.env.NX_BRANCH !== undefined) {
-        return process.env.NX_BRANCH;
-    }
-    if (process.env.CIRCLECI !== undefined) {
-        if (process.env.CIRCLE_PR_NUMBER !== undefined) {
-            return process.env.CIRCLE_PR_NUMBER;
-        }
-        else if (process.env.CIRCLE_PULL_REQUEST !== undefined) {
-            const p = process.env.CIRCLE_PULL_REQUEST.split('/');
-            return p[p.length - 1];
-        }
-        else if (process.env.CIRCLE_BRANCH !== undefined) {
-            return process.env.CIRCLE_BRANCH;
-        }
-    }
-    if (process.env.TRAVIS_PULL_REQUEST !== undefined) {
-        return process.env.TRAVIS_PULL_REQUEST;
-    }
-    // refs/pull/78/merge
-    if (process.env.GITHUB_ACTIONS) {
-        if (process.env.GITHUB_REF) {
-            const ref = process.env.GITHUB_REF.match(/refs\/pull\/(\d+)\/merge/);
-            if (ref) {
-                return ref[1];
-            }
-        }
-        return (_a = process.env.GITHUB_HEAD_REF) !== null && _a !== void 0 ? _a : '';
-    }
-    if (process.env.BITBUCKET_PR_ID !== undefined) {
-        return process.env.BITBUCKET_PR_ID;
-    }
-    if (process.env.VERCEL_GIT_COMMIT_REF !== undefined) {
-        return process.env.VERCEL_GIT_COMMIT_REF;
-    }
-    // Gitlab, merge request flow only
-    // For support: Users must have their pipeline configured as merge requests
-    // ONLY to have this variable appear.
-    // https://docs.gitlab.com/ee/ci/pipelines/merge_request_pipelines.html#use-only-to-add-jobs
-    if (process.env.CI_MERGE_REQUEST_IID) {
-        return process.env.CI_MERGE_REQUEST_IID;
-    }
-    // Gitlab, branch pipeline flow only
-    // Will not work with bot comments
-    if (process.env.CI_COMMIT_BRANCH) {
-        return process.env.CI_COMMIT_BRANCH;
+  var _a;
+  if (process.env.NX_BRANCH !== undefined) {
+    return process.env.NX_BRANCH;
+  }
+  if (process.env.CIRCLECI !== undefined) {
+    if (process.env.CIRCLE_PR_NUMBER !== undefined) {
+      return process.env.CIRCLE_PR_NUMBER;
+    } else if (process.env.CIRCLE_PULL_REQUEST !== undefined) {
+      const p = process.env.CIRCLE_PULL_REQUEST.split('/');
+      return p[p.length - 1];
+    } else if (process.env.CIRCLE_BRANCH !== undefined) {
+      return process.env.CIRCLE_BRANCH;
     }
-    // Jenkins, this will only be populated in MULTIBRANCH pipelines.
-    // Remember that if someone asks in support :)
-    if (process.env.GIT_BRANCH) {
-        return process.env.GIT_BRANCH;
+  }
+  if (process.env.TRAVIS_PULL_REQUEST !== undefined) {
+    return process.env.TRAVIS_PULL_REQUEST;
+  }
+  // refs/pull/78/merge
+  if (process.env.GITHUB_ACTIONS) {
+    if (process.env.GITHUB_REF) {
+      const ref = process.env.GITHUB_REF.match(/refs\/pull\/(\d+)\/merge/);
+      if (ref) {
+        return ref[1];
+      }
     }
-    return null;
+    return (_a = process.env.GITHUB_HEAD_REF) !== null && _a !== void 0
+      ? _a
+      : '';
+  }
+  if (process.env.BITBUCKET_PR_ID !== undefined) {
+    return process.env.BITBUCKET_PR_ID;
+  }
+  if (process.env.VERCEL_GIT_COMMIT_REF !== undefined) {
+    return process.env.VERCEL_GIT_COMMIT_REF;
+  }
+  // Gitlab, merge request flow only
+  // For support: Users must have their pipeline configured as merge requests
+  // ONLY to have this variable appear.
+  // https://docs.gitlab.com/ee/ci/pipelines/merge_request_pipelines.html#use-only-to-add-jobs
+  if (process.env.CI_MERGE_REQUEST_IID) {
+    return process.env.CI_MERGE_REQUEST_IID;
+  }
+  // Gitlab, branch pipeline flow only
+  // Will not work with bot comments
+  if (process.env.CI_COMMIT_BRANCH) {
+    return process.env.CI_COMMIT_BRANCH;
+  }
+  // Jenkins, this will only be populated in MULTIBRANCH pipelines.
+  // Remember that if someone asks in support :)
+  if (process.env.GIT_BRANCH) {
+    return process.env.GIT_BRANCH;
+  }
+  return null;
 }
 exports.getBranch = getBranch;
 function getMachineInfo() {
-    const os = require('os');
-    const hasher = (0, crypto_1.createHash)('md5');
-    hasher.update((0, node_machine_id_1.machineIdSync)());
-    const machineId = hasher.digest('base64');
-    return {
-        machineId,
-        platform: os.platform(),
-        version: os.version ? os.version() : '',
-        cpuCores: os.cpus().length,
-    };
+  const os = require('os');
+  const hasher = (0, crypto_1.createHash)('md5');
+  hasher.update((0, node_machine_id_1.machineIdSync)());
+  const machineId = hasher.digest('base64');
+  return {
+    machineId,
+    platform: os.platform(),
+    version: os.version ? os.version() : '',
+    cpuCores: os.cpus().length,
+  };
 }
 exports.getMachineInfo = getMachineInfo;
 function parseCommand() {
-    const cmdBase = (0, path_1.parse)(process.argv[1]).name;
-    const args = `${process.argv.slice(2).join(' ')}`;
-    return `${cmdBase} ${args}`;
+  const cmdBase = (0, path_1.parse)(process.argv[1]).name;
+  const args = `${process.argv.slice(2).join(' ')}`;
+  return `${cmdBase} ${args}`;
 }
 exports.parseCommand = parseCommand;
 //# sourceMappingURL=environment.js.map
